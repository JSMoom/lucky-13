### Group 13 

# Loading packages
library(cowplot)
library(plotly)
library(gridExtra)
library(tidyverse)
library(devtools)
library(oefenwebDatabase)
library(oefenwebTools)
library(lme4)
library(lmerTest)
library(lubridate)
library(DBI)
library(ggalluvial)

# Establishing connection with oefenweb
con <- oefenwebDatabase::connect()

# Create necessary objects
ed_logs <- list()
domains <- c(1:5, 7, 9, 10, 11, 59)
change_date <- as.Date("2024-10-25")
start_date <- as.Date("2023-09-01")

# Loop through each E_D table
for (i in 1:10) {
  # Write SQL query to get data, and convert to seconds
  query <- paste0("SELECT *
                   FROM extended_deadline_logs_", domains[i])
  # Get the data and store it in the list
  ed_logs[[i]] <- suppressWarnings(DBI::dbGetQuery(con, query))
}

# Turn the list into a single df
ed_logs <- bind_rows(ed_logs)

# Getting deadlines for items in 59
query <- paste0("SELECT id AS item_id,
                 maximum_response_in_seconds AS deadline
                 FROM extended_deadline_items
                 WHERE domain_id = 59")
# Get the data and store it in the list
deadlines_59 <- suppressWarnings(DBI::dbGetQuery(con, query))

# Convert created to date and into POSIXct format
ed_logs <- ed_logs %>%
  rename(date = created) 
ed_logs$date <-
  as.POSIXct(ed_logs$date, format = "%Y-%m-%d %H:%M:%S")

# Getting item deadlines for domain 59
items_5 <- deadlines_59 %>%
  filter(deadline == 5) %>%
  pull(item_id)

items_10 <- deadlines_59 %>%
  filter(deadline == 10) %>%
  pull(item_id)

items_15 <- deadlines_59 %>%
  filter(deadline == 15) %>%
  pull(item_id)

items_20 <- deadlines_59 %>%
  filter(deadline == 20) %>%
  pull(item_id)

# Categorical columns
cats <- colnames(ed_logs[,c(8:11, 14:15)])

# Adjustments to data
ed_logs = ed_logs %>%
  rename(response_in_seconds = response_in_milliseconds) %>%
  mutate(deadline = case_when(
    domain_id %in% c(1:4, 7, 10) ~ 20,
    domain_id %in% c(9) ~ 30,
    domain_id %in% c(11) ~ 60,
    domain_id == 5 ~ 8,
    domain_id == 59 & item_id %in% items_5 ~ 5,
    domain_id == 59 & item_id %in% items_10 ~ 10,
    domain_id == 59 & item_id %in% items_15 ~ 15,
    domain_id == 59 & item_id %in% items_20 ~ 20),
    response_in_seconds = response_in_seconds / 1000,
    across(all_of(cats), as.factor)
  ) 

# Adding time_weeks column and organizing by user_id then date
ed_logs <- ed_logs %>%
  group_by(user_id) %>%
  arrange(user_id, date) %>%
  mutate(time_weeks = ceiling(as.numeric(
    difftime(date, start_date, units = "weeks")
  ))) %>%
  mutate(time_weeks = ifelse(time_weeks < 1, 1, time_weeks)) %>%  # Ensure any negative or 0 values are set to 1
  ungroup()   

# Total number of unique users
num_users <- n_distinct(ed_logs$user_id)
# 23305

# Finding users that alternate between showing coins and not
swappers <- ed_logs %>%
  select(user_id, show_coins) %>%
  distinct(user_id, show_coins) %>%       # Get unique choices
  count(user_id) %>%                    
  filter(n == 2) %>%                    
  pull(user_id)
# 11118 users have swapped at least once
# Proportion
length(swappers) / num_users # .477065

# Finding users that have never swapped between showing coins or not
not_swappers <- ed_logs %>%
  select(user_id, show_coins) %>%
  distinct(user_id, show_coins) %>%       # Get unique choices
  count(user_id) %>%                    
  filter(n == 1) %>%                    
  pull(user_id)
# 12187 users have never swapped
# Proportion
length(not_swappers) / num_users # .522935

# Users that don't show coins
no_shows <- ed_logs %>%
  distinct(user_id, show_coins) %>%
  filter(user_id %in% not_swappers & show_coins == 0) %>%
  pull(user_id)
# 132 users never showed coins
# Proportion
length(no_shows) / num_users # .005664021

# Investigating swapping behavior, especially for those swapping to show coins after change

# Getting data needed for sankey plot
sankey_data <- ed_logs %>%
  select(user_id, show_coins, time_weeks) %>%
  filter(user_id %in% swappers) %>%
  mutate(interval = cut(time_weeks, breaks = seq(0, max(time_weeks), by = 2), labels = FALSE))


# Group by individual and interval, then summarize
sankey_tibble <- sankey_data %>%
  group_by(user_id, interval) %>%
  summarize(mode_show_coins = names(which.max(table(show_coins)))) %>%
  ungroup()

# Make the plot
sankey_tibble %>%
  ggplot(aes(x = interval, stratum = mode_show_coins, alluvium = user_id, fill = mode_show_coins, label = mode_show_coins)) +
  theme_minimal() +
  #scale_fill_manual(values = color_scheme2) +
  geom_flow(color = "darkgray") +
  geom_stratum() +
  theme(legend.position = "top") +
  labs(x = "2-Week Intervals", y = "Users", title = "Mode show_coins across 2-Week Intervals", legend = "Mode show_coins")

# Further checking
stuff <- ed_logs %>%
  select(user_id, show_coins, time_weeks) %>%
  filter(user_id %in% swappers)

sum(stuff$show_coins[stuff$user_id == 1386] == 0)

sum(ed_logs$session == "learning_goal")


# Check the structure and unique values in domain_id
str(ed_logs)
unique(ed_logs$domain_id)

# Add a new variable indicating whether the response was late
# late_response: 1 indicates late response, 0 indicates on-time response
ed_logs <- ed_logs %>%
  mutate(late_response = ifelse(response_in_seconds > deadline, 1, 0))

# Show the earliest and latest date in the dataset
earliest_date <- min(ed_logs$date, na.rm = TRUE)
latest_date <- max(ed_logs$date, na.rm = TRUE)
print(paste("Earliest date:", earliest_date))
print(paste("Latest date:", latest_date))

## ----------------------------------------------------------------------------
data <- ed_logs %>%
  mutate(grade = as.numeric(as.character(grade))) %>%  # Convert grade from factor to numeric
  filter(grade >= 3 & grade <= 8)  # Keep only grades between 3 and 8

# Define the range
start_date <- as.Date("2024-09-05")
end_date <- as.Date("2024-12-14")

# Filter the data
data <- subset(data, date >= start_date & date <= end_date)

# View the filtered data
print(data)

# Add the 'help' column
data$help <- ifelse(data$answer == "¿", 1, 0)

# View the updated dataset
print(data)

# Add the 'no_answer' column
data$no_answer <- ifelse(data$answer == "…", 1, 0)

# View the updated dataset
print(data)

data$learning_goal <- ifelse(data$session == "learning_goal", 1, 0)

# Function to calculate the mode
calculate_mode <- function(x) {
  unique_x <- unique(x)
  unique_x[which.max(tabulate(match(x, unique_x)))]
}

# Add a column for mode of difficulty based on user_id
data <- data %>%
  group_by(user_id) %>%
  mutate(modeDifficulty = calculate_mode(difficulty)) %>%
  ungroup()


# Define the reference date
reference_date <- as.Date("2024-10-25")

# Add the 'new_UI' column
data$new_UI <- ifelse(data$date > reference_date, 1, 0)

# Filter data for late_response = 1 and new_UI = 0
filtered_data <- data %>%
  filter(late_response == 1 & new_UI == 0)

# View the filtered data to see if there are any late responses before the new UI
# because that is impossible 
print(filtered_data)

# Calculate proportion of help grouped by new_UI
help_proportion <- data %>%
  group_by(new_UI) %>%
  summarise(
    total_responses = n(),
    help_count = sum(help),
    help_proportion = mean(help) # Proportion of help (help = 1)
  )

# View the result
print(help_proportion)

# Calculate proportion of help grouped by new_UI
no_answer <- data %>%
  group_by(new_UI) %>%
  summarise(
    total_responses = n(),
    no_answer_count = sum(no_answer),
    no_answe_proportion= mean(no_answer) # Proportion of help (help = 1)
  )

# View the result
print(no_answer)

# Calculate proportion of no_answer grouped by new_UI and domain_id
no_answer_by_domain <- data %>%
  group_by(new_UI, domain_id) %>%
  summarise(
    total_responses = n(),
    no_answer_count = sum(no_answer),
    no_answer_proportion = mean(no_answer) # Proportion of no_answer (no_answer = 1)
  )

# View the result
print(no_answer_by_domain)

# Convert proportions to percentages and sort by `new_UI = 0`
no_answer_by_domain <- no_answer_by_domain %>%
  mutate(no_answer_percentage = no_answer_proportion * 100) %>%
  arrange(desc(ifelse(new_UI == 0, no_answer_percentage, NA)))

# Bar plot for No Answer with custom colors, centered title, and legend adjustments
ggplot(no_answer_by_domain, aes(x = reorder(domain_id, -no_answer_percentage), y = no_answer_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Percentage of No Answer by Domain",
    x = "Domain ID",
    y = "Percentage of No Answer",
    fill = "October 25th"
  ) +
  scale_fill_manual(
    values = c("0" = "#57b0b5", "1" = "#fe6c66"),
    labels = c("0" = "Before", "1" = "After")  # Custom legend labels
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),  # Center title
    legend.position = "bottom",  # Position legend at the bottom
    legend.title = element_text(face = "bold"),  # Bold legend title
    legend.text = element_text(size = 10)       # Adjust legend text size
  )

## ----------------------------------------------------------------------------

# Convert proportions of help into percentages and sort by `new_UI = 0`
help_by_domain <- data %>%
  group_by(new_UI, domain_id) %>%
  summarise(
    total_responses = n(),
    help_count = sum(help),
    help_proportion = mean(help)
  ) %>%
  mutate(help_percentage = help_proportion * 100) %>%
  arrange(desc(ifelse(new_UI == 0, help_percentage, NA)))


# Sort data by the highest help percentage for new_UI = 0
help_by_domain_sorted <- help_by_domain %>%
  arrange(desc(ifelse(new_UI == 0, help_percentage, NA))) %>%
  mutate(domain_id = factor(domain_id, levels = unique(domain_id)))  # Preserve sorted order

# Bar plot for Help with custom colors, centered title, and legend adjustments
ggplot(help_by_domain_sorted, aes(x = domain_id, y = help_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Percentage of Help by Domain",
    x = "Domain ID",
    y = "Percentage of Help",
    fill = "October 25th"
  ) +
  scale_fill_manual(
    values = c("0" = "#57b0b5", "1" = "#fe6c66"),
    labels = c("0" = "Before", "1" = "After")  # Custom legend labels
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),  # Center title
    legend.position = "bottom",  # Position legend at the bottom
    legend.title = element_text(face = "bold"),  # Bold legend title
    legend.text = element_text(size = 10)       # Adjust legend text size
  )


## ----------------------------------------------------------------------------
# Summarize no_answer by new_UI and modeDifficulty
no_answer_by_mode <- data %>%
  group_by(new_UI, modeDifficulty) %>%
  summarise(
    total_responses = n(),
    no_answer_count = sum(no_answer),
    no_answer_percentage = (sum(no_answer) / n()) * 100
  ) %>%
  ungroup() %>%
  mutate(
    modeDifficultyLabel = case_when(
      modeDifficulty == "0" ~ "Easy",
      modeDifficulty == "1" ~ "Medium",
      modeDifficulty == "2" ~ "Hard",
      TRUE ~ "Unknown"
    )
  )

# Bar chart
ggplot(no_answer_by_mode, aes(x = factor(modeDifficultyLabel, levels = c("Easy", "Medium", "Hard")), 
                              y = no_answer_percentage, 
                              fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  scale_fill_manual(
    values = c("0" = "#57b0b5", "1" = "#fe6c66"),
    labels = c("0" = "Before", "1" = "After")
  ) +
  labs(
    title = "Percentage of No Answer by Mode Difficulty",
    x = " ",
    y = "Percentage of No Answer",
    fill = "October 25th"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Centered and bold title
    legend.position = "bottom",                                       # Legend at the bottom
    legend.title = element_text(face = "bold"),                       # Bold legend title
    legend.text = element_text(size = 10)                             # Adjust legend text size
  )


## ----------------------------------------------------------------------------

# correct answers 
correct_answers_ui <- data %>%
group_by(new_UI, domain_id) %>%
  summarise(
    total_responses = n(),
    correct_responses = sum(correct_answered == "1"),
    correct_percentage = mean(correct_answered == "1") * 100
  ) %>%
  ungroup() %>%
  mutate(
    UI_Status = ifelse(new_UI == 0, "Old", "New")  # Label as "Old" or "New"
  )
# Sort data by the highest correct percentage for Old UI
correct_answers_ui_sorted <- correct_answers_ui %>%
  arrange(desc(ifelse(new_UI == 0, correct_percentage, NA))) %>%
  mutate(domain_id = factor(domain_id, levels = unique(domain_id)))  # Preserve the sorted order

# Grouped bar chart
ggplot(correct_answers_ui_sorted, aes(x = domain_id, y = correct_percentage, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  labs(
    title = "Percentage of Correct Answers by Domain (Old vs New)",
    x = "Domain ID",
    y = "Percentage of Correct Answers",
    fill = "October 25th"
  ) +
  theme_minimal() +
  scale_fill_manual(values = c("Old" = "#57b0b5", "New" = "#fe6c66")) +  # Custom colors
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Centered and bold title
    legend.position = "bottom",                                       # Legend at the bottom
    legend.title = element_text(face = "bold"),                       # Bold legend title
    legend.text = element_text(size = 10)                             # Adjust legend text size
  )


## ----------------------------------------------------------------------------

# Step 1: Exclude late responses where no_answer = 1
filtered_data <- data %>%
  filter(!(late_response == 1 & no_answer == 1))  # Exclude these cases

# Step 2: Calculate average, SD of late responses per user
late_responses_stats <- filtered_data %>%
  group_by(user_id) %>%
  summarise(
    total_late_responses = sum(late_response, na.rm = TRUE),  # Total valid late responses per user
    .groups = "drop"
  ) %>%
  summarise(
    average_late = mean(total_late_responses),
    sd_late = sd(total_late_responses)
  )

# Print the average and SD
print("Average and SD of late responses per user (excluding no_answer = 1):")
print(late_responses_stats)

# Step 3: Calculate the longest streak of late responses excluding no_answer = 1
longest_streak_per_user <- filtered_data %>%
  arrange(user_id, date) %>%  # Ensure data is ordered by user_id and date
  group_by(user_id) %>%
  mutate(
    streak_id = cumsum(late_response != lag(late_response, default = 0)),  # Identify streaks
    late_response_streak = ifelse(late_response == 1, streak_id, NA)       # Keep streak IDs for late responses
  ) %>%
  filter(!is.na(late_response_streak)) %>%  # Keep only late response streaks
  group_by(user_id, late_response_streak) %>%
  summarise(streak_length = n(), .groups = "drop") %>%  # Calculate streak lengths
  group_by(user_id) %>%
  summarise(longest_streak = max(streak_length), .groups = "drop")  # Find the longest streak per user

# Print the longest streak
print("Longest streak of late responses per user (excluding no_answer = 1):")
print(longest_streak_per_user)



# Explore the trend of late responses over time (weekly)
late_response_time_trend <- ed_logs %>%
  mutate(week = lubridate::floor_date(date, "week")) %>%
  group_by(week) %>%
  summarize(
    total_responses = n(),
    late_responses = sum(late_response),
    late_response_rate = mean(late_response)
  )

# Visualize the trend
late_response_time_trend %>%
  ggplot(aes(x = week, y = late_response_rate)) +
  geom_line(color = "blue") +
  labs(
    title = "Trend of Late Responses Over Time",
    x = "Week",
    y = "Late Response Rate"
  ) +
  theme_minimal()

# Temporal Patterns
# Late Response by Hour of Day
# hour: extracted from the timestamp to analyze time-based patterns

# Calculate late response rate by hour, excluding no_answer = 1, and format as percentage
late_response_by_hour <- data %>%
  filter(!(late_response == 1 & no_answer == 1)) %>%  # Exclude rows where no_answer = 1
  mutate(hour = hour(date)) %>%  # Extract the hour from the date
  group_by(hour) %>%
  summarize(
    total_responses = n(),
    late_responses = sum(late_response),
    late_response_rate = round(mean(late_response) * 100, 2),  # Convert rate to percentage with 2 decimals
    .groups = "drop"
  )

# Print the late response rate by hour
print("Late Response Rate by Hour of Day (Excluding no_answer = 1, as Percentage):")
print(late_response_by_hour)

# Plot late response rate by hour
late_response_by_hour %>%
  ggplot(aes(x = hour, y = late_response_rate)) +
  geom_line(color = "#57b0b5", size = 1.2) +
  geom_point(color = "#57b0b5", size = 3) +
  labs(
    title = "Late Response Rate by Hour of Day",
    x = "Hour of Day",
    y = "Late Response Rate (%)"
  ) +
  theme_minimal()

## ----------------------------------------------------------------------------

# Calculate late response rate by day of the week, excluding no_answer = 1
late_response_by_day <- data %>%
  filter(!(late_response == 1 & no_answer == 1)) %>%  # Exclude rows where no_answer = 1
  mutate(weekday = wday(date, label = TRUE, week_start = 1)) %>%  # Extract weekday starting with Monday
  group_by(weekday) %>%
  summarize(
    total_responses = n(),
    late_responses = sum(late_response),
    late_response_rate = round(mean(late_response) * 100, 2),  # Convert rate to percentage with 2 decimals
    .groups = "drop"
  ) %>%
  mutate(
    weekday = factor(weekday, levels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"))  # Set the order
  )

# Print the late response rate by day of the week
print("Late Response Rate by Day of the Week (Excluding no_answer = 1, as Percentage):")
print(late_response_by_day)

# Plot late response rate by day of the week
late_response_by_day %>%
  ggplot(aes(x = weekday, y = late_response_rate)) +
  geom_col(fill = "#57b0b5") +  # Use a custom color
  labs(
    title = "Late Response Rate by Day of the Week",
    x = "Day of the Week",
    y = "Late Response Rate (%)"
  ) +
  theme_minimal()


## ----------------------------------------------------------------------------

# Step 1: Calculate total items answered per user before and after new_UI
items_per_user <- data %>%
  group_by(user_id, new_UI) %>%  # Group by user and UI type
  summarise(
    items_answered = n(),  # Total items answered per user
    .groups = "drop"
  )

# Step 2: Create a boxplot comparing items answered before and after the new UI
ggplot(items_per_user, aes(x = factor(new_UI, labels = c("Before", "After")), y = items_answered)) +
  geom_boxplot(fill = c("#57b0b5", "#fe6c66")) +
  labs(
    title = "Items Answered Per User: Before vs After New UI",
    x = "UI Version",
    y = "Number of Items Answered"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")  # Centered and bold title
  )

ggplot(items_per_user, aes(x = factor(new_UI, labels = c("Before", "After")), y = items_answered)) +
  geom_boxplot(fill = c("#57b0b5", "#fe6c66")) +
  scale_y_log10() +
  labs(
    title = "Items Answered Per User: Before vs After New UI (Log Scale)",
    x = "Counted all items 8 weeks prior the new UI and after the new UI",
    y = "Number of Items Answered (Log Scale)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
  )


# Step 1: Count learning_goal = 1 per user before and after the new UI
learning_goal_per_user <- data %>%
  filter(learning_goal == 1) %>%  # Filter rows where learning_goal = 1
  group_by(user_id, new_UI) %>%   # Group by user and UI version
  summarise(
    learning_goal_count = n(),    # Count occurrences per user
    .groups = "drop"
  ) %>%
  mutate(UI_Status = ifelse(new_UI == 0, "Before", "After"))  # Add readable labels

# Step 2: Plot the data as a boxplot
ggplot(learning_goal_per_user, aes(x = UI_Status, y = learning_goal_count, fill = UI_Status)) +
  geom_boxplot() +
  scale_fill_manual(values = c("Before" = "#57b0b5", "After" = "#fe6c66")) +
  labs(
    title = "Learning Goal = 1 Counts Per User: Before vs After New UI",
    x = "UI Version",
    y = "Count of Learning Goal = 1 Per User",
    fill = "UI Version"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Centered and bold title
    legend.position = "none"  # Remove legend for simplicity
  )

ggplot(learning_goal_per_user, aes(x = UI_Status, y = learning_goal_count, fill = UI_Status)) +
  geom_boxplot() +
  scale_y_log10() +  # Apply log scale to the y-axis
  scale_fill_manual(values = c("Before" = "#57b0b5", "After" = "#fe6c66")) +
  labs(
    title = "Learning Goal Counts Per User: Before vs After New UI (Log Scale)",
    x = "Counted learning goal sessions 8 weeks prior the new UI and after the new UI",
    y = "Count of Learning Goal = 1 Per User (Log Scale)",
    fill = "UI Version"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Centered and bold title
    legend.position = "none"  # Remove legend for simplicity
  )


# Step 1: Filter data to exclude rows where no_answer = 1
filtered_data <- data %>%
  filter(!(late_response == 1 & no_answer == 1))  # Exclude cases where no_answer = 1

# Step 2: Calculate percentage of late responses per grade
late_response_percentage <- filtered_data %>%
  group_by(grade) %>%
  summarise(
    total_responses = n(),                      # Total responses per grade
    late_responses = sum(late_response),        # Total late responses per grade
    late_response_percentage = round((sum(late_response) / n()) * 100, 2),  # Late response percentage
    .groups = "drop"
  )

# Step 3: Print the summary table
print("Percentage of Late Responses per Grade (Excluding no_answer = 1):")
print(late_response_percentage)

# Step 4: Plot the percentage of late responses per grade
ggplot(late_response_percentage, aes(x = factor(grade), y = late_response_percentage)) +
  geom_col(fill = "#57b0b5") +
  labs(
    title = "Percentage of Late Responses per Grade",
    x = "Grade",
    y = "Late Response Percentage (%)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
  )


# Step 1: Calculate percentage of no_answer per grade before and after the new UI
no_answer_percentage <- data %>%
  group_by(new_UI, grade) %>%  # Group by grade and new_UI (before/after)
  summarise(
    total_responses = n(),                    # Total responses per group
    no_answer_count = sum(no_answer),         # Total no_answer per group
    no_answer_percentage = round((sum(no_answer) / n()) * 100, 2),  # Percentage of no_answer
    .groups = "drop"
  ) %>%
  mutate(UI_Status = ifelse(new_UI == 0, "Before", "After"))  # Add readable labels for UI status

# Step 2: Print the summary table
print("Percentage of No Answer per Grade Before and After the New UI:")
print(no_answer_percentage)

# Step 3: Plot the percentage of no_answer per grade
ggplot(no_answer_percentage, aes(x = factor(grade), y = no_answer_percentage, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = c("Before" = "#57b0b5", "After" = "#fe6c66")) +
  labs(
    title = "Percentage of No Answer per Grade Before and After the New UI",
    x = "Grade",
    y = "No Answer Percentage (%)",
    fill = " "
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
  )


# Step 1: Calculate percentage of help per grade before and after the new UI
help_percentage <- data %>%
  group_by(new_UI, grade) %>%  # Group by grade and new_UI (before/after)
  summarise(
    total_responses = n(),               # Total responses per group
    help_count = sum(help),              # Total help responses per group
    help_percentage = round((sum(help) / n()) * 100, 2),  # Percentage of help
    .groups = "drop"
  ) %>%
  mutate(UI_Status = ifelse(new_UI == 0, "Before", "After"))  # Add readable labels for UI status

# Step 2: Print the summary table
print("Percentage of Help per Grade Before and After the New UI:")
print(help_percentage)

# Step 3: Plot the percentage of help per grade
ggplot(help_percentage, aes(x = factor(grade), y = help_percentage, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = c("Before" = "#57b0b5", "After" = "#fe6c66")) +
  labs(
    title = "Percentage of Help per Grade Before and After the New UI",
    x = "Grade",
    y = "Help Percentage (%)",
    fill = "  "
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
  )


oefenwebDatabase::close_connection(con)
```
