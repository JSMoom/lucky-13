### Group 13 

# Loading packages
library(cowplot)
library(plotly)
library(gridExtra)
library(tidyverse)
library(devtools)
library(oefenwebDatabase)
library(oefenwebTools)
library(lme4)
library(lmerTest)
library(lubridate)
library(DBI)
library(ggalluvial)
library(car)

# Establishing connection with oefenweb
con <- oefenwebDatabase::connect()

# Create necessary objects
ed_logs <- list()
domains <- c(1:5, 7, 9, 10, 11, 59)
change_date <- as.Date("2024-10-25")
start_date <- as.Date("2023-09-01")

# Loop through each E_D table
for (i in 1:10) {
  # Write SQL query to get data, and convert to seconds
  query <- paste0("SELECT *
                   FROM extended_deadline_logs_", domains[i])
  # Get the data and store it in the list
  ed_logs[[i]] <- suppressWarnings(DBI::dbGetQuery(con, query))
}

# Turn the list into a single df
ed_logs <- bind_rows(ed_logs)

# Getting deadlines for items in 59
query <- paste0("SELECT id AS item_id,
                 maximum_response_in_seconds AS deadline
                 FROM extended_deadline_items
                 WHERE domain_id = 59")
# Get the data and store it in the list
deadlines_59 <- suppressWarnings(DBI::dbGetQuery(con, query))

# Convert created to date and into POSIXct format
ed_logs <- ed_logs %>%
  rename(date = created) 
ed_logs$date <-
  as.POSIXct(ed_logs$date, format = "%Y-%m-%d %H:%M:%S")

# Getting item deadlines for domain 59
items_5 <- deadlines_59 %>%
  filter(deadline == 5) %>%
  pull(item_id)

items_10 <- deadlines_59 %>%
  filter(deadline == 10) %>%
  pull(item_id)

items_15 <- deadlines_59 %>%
  filter(deadline == 15) %>%
  pull(item_id)

items_20 <- deadlines_59 %>%
  filter(deadline == 20) %>%
  pull(item_id)

# Categorical columns
cats <- colnames(ed_logs[,c(8:11, 14:15)])

# Adjustments to data
ed_logs = ed_logs %>%
  rename(response_in_seconds = response_in_milliseconds) %>%
  mutate(deadline = case_when(
    domain_id %in% c(1:4, 7, 10) ~ 20,
    domain_id %in% c(9) ~ 30,
    domain_id %in% c(11) ~ 60,
    domain_id == 5 ~ 8,
    domain_id == 59 & item_id %in% items_5 ~ 5,
    domain_id == 59 & item_id %in% items_10 ~ 10,
    domain_id == 59 & item_id %in% items_15 ~ 15,
    domain_id == 59 & item_id %in% items_20 ~ 20),
    response_in_seconds = response_in_seconds / 1000,
    across(all_of(cats), as.factor)
  ) 

# Adding time_weeks column and organizing by user_id then date
ed_logs <- ed_logs %>%
  group_by(user_id) %>%
  arrange(user_id, date) %>%
  mutate(time_weeks = ceiling(as.numeric(
    difftime(date, start_date, units = "weeks")
  ))) %>%
  mutate(time_weeks = ifelse(time_weeks < 1, 1, time_weeks)) %>%  # Ensure any negative or 0 values are set to 1
  ungroup()   

# Total number of unique users
num_users <- n_distinct(ed_logs$user_id)
# 23305

# Finding users that alternate between showing coins and not
swappers <- ed_logs %>%
  select(user_id, show_coins) %>%
  distinct(user_id, show_coins) %>%       # Get unique choices
  count(user_id) %>%                    
  filter(n == 2) %>%                    
  pull(user_id)
# 11118 users have swapped at least once
# Proportion
length(swappers) / num_users # .477065

# Finding users that have never swapped between showing coins or not
not_swappers <- ed_logs %>%
  select(user_id, show_coins) %>%
  distinct(user_id, show_coins) %>%       # Get unique choices
  count(user_id) %>%                    
  filter(n == 1) %>%                    
  pull(user_id)
# 12187 users have never swapped
# Proportion
length(not_swappers) / num_users # .522935

# Users that don't show coins
no_shows <- ed_logs %>%
  distinct(user_id, show_coins) %>%
  filter(user_id %in% not_swappers & show_coins == 0) %>%
  pull(user_id)
# 132 users never showed coins
# Proportion
length(no_shows) / num_users # .005664021

# Investigating swapping behavior, especially for those swapping to show coins after change

# Getting data needed for sankey plot
sankey_data <- ed_logs %>%
  select(user_id, show_coins, time_weeks) %>%
  filter(user_id %in% swappers) %>%
  mutate(interval = cut(time_weeks, breaks = seq(0, max(time_weeks), by = 2), labels = FALSE))


# Group by individual and interval, then summarize
sankey_tibble <- sankey_data %>%
  group_by(user_id, interval) %>%
  summarize(mode_show_coins = names(which.max(table(show_coins)))) %>%
  ungroup()

# Make the plot
sankey_tibble %>%
  ggplot(aes(x = interval, stratum = mode_show_coins, alluvium = user_id, fill = mode_show_coins, label = mode_show_coins)) +
  theme_minimal() +
  #scale_fill_manual(values = color_scheme2) +
  geom_flow(color = "darkgray") +
  geom_stratum() +
  theme(legend.position = "top") +
  labs(x = "2-Week Intervals", y = "Users", title = "Mode show_coins across 2-Week Intervals", legend = "Mode show_coins")

# Further checking
stuff <- ed_logs %>%
  select(user_id, show_coins, time_weeks) %>%
  filter(user_id %in% swappers)

sum(stuff$show_coins[stuff$user_id == 1386] == 0)

sum(ed_logs$session == "learning_goal")

# Check the structure and unique values in domain_id
str(ed_logs)
unique(ed_logs$domain_id)

# Add a new variable indicating whether the response was late
# late_response: 1 indicates late response, 0 indicates on-time response
ed_logs <- ed_logs %>%
  mutate(late_response = ifelse(response_in_seconds > deadline, 1, 0))

# Show the earliest and latest date in the dataset
earliest_date <- min(ed_logs$date, na.rm = TRUE)
latest_date <- max(ed_logs$date, na.rm = TRUE)
print(paste("Earliest date:", earliest_date))
print(paste("Latest date:", latest_date))

## ----------------------------------------------------------------------------
## Data Preparation
data <- ed_logs %>%
  mutate(grade = as.numeric(as.character(grade))) %>%  # Convert grade from factor to numeric
  filter(grade >= 3 & grade <= 8)  # Keep only grades between 3 and 8

# Define the range
start_date <- as.Date("2024-09-05")
end_date <- as.Date("2024-12-14")

# Filter the data
data <- subset(data, date >= start_date & date <= end_date)

# Add the 'help' column
data$help <- ifelse(data$answer == "¿", 1, 0)

# Add the 'no_answer' column
data$no_answer <- ifelse(data$answer == "…", 1, 0)

data$learning_goal <- ifelse(data$session == "learning_goal", 1, 0)

# Function to calculate the mode
calculate_mode <- function(x) {
  unique_x <- unique(x)
  unique_x[which.max(tabulate(match(x, unique_x)))]
}

# Add a column for mode of difficulty based on user_id
data <- data %>%
  group_by(user_id) %>%
  mutate(modeDifficulty = calculate_mode(difficulty)) %>%
  ungroup()

# Define the reference date
reference_date <- as.Date("2024-10-25")

# Add the 'new_UI' column
data$new_UI <- factor(ifelse(data$date > reference_date, "After", "Before"), 
                      levels = c("Before", "After"))


# Map domain IDs to domain names
domain_names <- c(
  "1" = "Addition",
  "2" = "Subtraction",
  "3" = "Multiplication",
  "4" = "Division",
  "5" = "Mix",
  "7" = "Counting",
  "9" = "Clock",
  "10" = "Series",
  "11" = "Numerals",
  "59" = "Tables"
)

data$domain_name <- domain_names[as.character(data$domain_id)]

# Define a consistent theme for all plots
custom_theme <- theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    legend.position = "bottom",
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 10)
  )

custom_colors <- c("Before" = "#00BFC4", "After" = "#F8766D")  # Adjust colors as needed



## ---------------------------------------------------------------------------- No Answer - with Error bars


plot1 <- data %>%
  group_by(new_UI, domain_name) %>%
  summarise(
    no_answer_percentage = mean(no_answer) * 100,
    sd = sd(no_answer) * 100,  
    .groups = 'drop'
  ) %>%
  ggplot(aes(y = reorder(domain_name, no_answer_percentage), x = no_answer_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(xmin = no_answer_percentage - sd, xmax = no_answer_percentage + sd),
                width = 0.2, position = position_dodge(0.9)) +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of No Answer by Domain", y = "Domain", x = "Percentage of No Answer", fill = "Update on Oct 25th") +
  custom_theme


plot2 <- data %>%
  group_by(new_UI, grade) %>%
  summarise(
    no_answer_percentage = mean(no_answer) * 100,
    sd = sd(no_answer) * 100,
    .groups = 'drop'
  ) %>%
  ggplot(aes(x = factor(grade), y = no_answer_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(ymin = no_answer_percentage - sd, ymax = no_answer_percentage + sd),
                width = 0.2, position = position_dodge(0.9)) +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of No Answer by Grade", x = "Grade", y = "Percentage of No Answer", fill = "Update on Oct 25th") +
  custom_theme


plot3 <- data %>%
  group_by(new_UI, modeDifficulty) %>%
  summarise(
    no_answer_percentage = mean(no_answer) * 100,
    sd = sd(no_answer) * 100,
    .groups = 'drop'
  ) %>%
  mutate(
    modeDifficultyLabel = factor(
      case_when(
        modeDifficulty == "0" ~ "Easy",
        modeDifficulty == "1" ~ "Medium",
        modeDifficulty == "2" ~ "Hard"
      ),
      levels = c("Easy", "Medium", "Hard") # Set the desired order
    )
  ) %>%
  ggplot(aes(x = modeDifficultyLabel, y = no_answer_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(ymin = no_answer_percentage - sd, ymax = no_answer_percentage + sd),
                width = 0.2, position = position_dodge(0.9)) +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of No Answer by Mode Difficulty", x = "Mode Difficulty", y = "Percentage of No Answer", fill = "Update on Oct 25th") +
  custom_theme


plot4 <- data %>%
  group_by(new_UI, learning_goal) %>%
  summarise(
    no_answer_percentage = mean(no_answer) * 100,
    sd = sd(no_answer) * 100,
    .groups = 'drop'
  ) %>%
  ggplot(aes(x = factor(learning_goal, labels = c("No", "Yes")), y = no_answer_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(ymin = no_answer_percentage - sd, ymax = no_answer_percentage + sd),
                width = 0.2, position = position_dodge(0.9)) +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of No Answer for Learning Goal Sessions", x = "Learning Goal Session", y = "Percentage of No Answer", fill = "Update on Oct 25th") +
  custom_theme


# Combine all plots into a 2x2 grid
grid.arrange(plot1, plot2, plot3, plot4, ncol = 2)
## ---------------------------------------------------------------------------- No Answer - without Error bars


plot1 <- data %>%
  group_by(new_UI, domain_name) %>%
  summarise(
    no_answer_percentage = mean(no_answer) * 100,
    sd = sd(no_answer) * 100,  
    .groups = 'drop'
  ) %>%
  ggplot(aes(y = reorder(domain_name, no_answer_percentage), x = no_answer_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of No Answer by Domain", y = "Domain", x = "Percentage of No Answer", fill = "Update on Oct 25th") +
  custom_theme


plot2 <- data %>%
  group_by(new_UI, grade) %>%
  summarise(
    no_answer_percentage = mean(no_answer) * 100,
    sd = sd(no_answer) * 100,
    .groups = 'drop'
  ) %>%
  ggplot(aes(x = factor(grade), y = no_answer_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of No Answer by Grade", x = "Grade", y = "Percentage of No Answer", fill = "Update on Oct 25th") +
  custom_theme


plot3 <- data %>%
  group_by(new_UI, modeDifficulty) %>%
  summarise(
    no_answer_percentage = mean(no_answer) * 100,
    sd = sd(no_answer) * 100,
    .groups = 'drop'
  ) %>%
  mutate(
    modeDifficultyLabel = factor(
      case_when(
        modeDifficulty == "0" ~ "Easy",
        modeDifficulty == "1" ~ "Medium",
        modeDifficulty == "2" ~ "Hard"
      ),
      levels = c("Easy", "Medium", "Hard") # Set the desired order
    )
  ) %>%
  ggplot(aes(x = modeDifficultyLabel, y = no_answer_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of No Answer by Mode Difficulty", x = "Mode Difficulty", y = "Percentage of No Answer", fill = "Update on Oct 25th") +
  custom_theme


plot4 <- data %>%
  group_by(new_UI, learning_goal) %>%
  summarise(
    no_answer_percentage = mean(no_answer) * 100,
    sd = sd(no_answer) * 100,
    .groups = 'drop'
  ) %>%
  ggplot(aes(x = factor(learning_goal, labels = c("No", "Yes")), y = no_answer_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of No Answer for Learning Goal Sessions", x = "Learning Goal Session", y = "Percentage of No Answer", fill = "Update on Oct 25th") +
  custom_theme


# Combine all plots into a 2x2 grid
grid.arrange(plot1, plot2, plot3, plot4, ncol = 2)
## ------------------------------------------------------------------ Statistical testss

group_summary <- data %>%
  group_by(new_UI) %>%
  summarise(
    mean_no_answer = mean(no_answer, na.rm = TRUE),
    sd_no_answer = sd(no_answer, na.rm = TRUE),
    n = n()
  )
# Prepare the data
test_data <- data %>%
  group_by(new_UI, user_id) %>%  # Assuming individual-level responses
  summarise(
    no_answer_mean = mean(no_answer, na.rm = TRUE)  # Mean no_answer per student
  ) %>%
  ungroup()

# Perform an independent t-test
t_test_result <- t.test(
  no_answer_mean ~ new_UI,  # Compare "Before" vs "After"
  data = test_data,
  var.equal = FALSE  # Use Welch's t-test (default), which is robust to unequal variances
)

# Output the results
cat("T-Test Results:\n")
print(t_test_result)

# Define a function to perform t-tests within subgroups
perform_subgroup_t_test <- function(data, subgroup_var) {
  data %>%
    group_by(!!sym(subgroup_var)) %>%  # Group by the subgroup variable
    summarise(
      t_test_result = list(t.test(no_answer ~ new_UI, data = cur_data(), var.equal = FALSE)),
      .groups = "drop"
    ) %>%
    mutate(
      subgroup = !!sym(subgroup_var),
      t_statistic = map_dbl(t_test_result, ~ .x$statistic),
      p_value = map_dbl(t_test_result, ~ .x$p.value),
      mean_diff = map_dbl(t_test_result, ~ diff(.x$estimate)),
      conf_low = map_dbl(t_test_result, ~ .x$conf.int[1]),
      conf_high = map_dbl(t_test_result, ~ .x$conf.int[2])
    ) %>%
    select(subgroup, t_statistic, p_value, mean_diff, conf_low, conf_high)
}

# Apply the function for each subgroup variable
results_by_domain <- perform_subgroup_t_test(data, "domain_id")
results_by_grade <- perform_subgroup_t_test(data, "grade")
results_by_difficulty <- perform_subgroup_t_test(data, "modeDifficulty")
results_by_learning_goal <- perform_subgroup_t_test(data, "learning_goal")

# Display results
results_by_domain
results_by_grade
results_by_difficulty
results_by_learning_goal


# ---------------------------------------------------------------------------- Help - with Error Bars

plot1 <- data %>%
  group_by(new_UI, domain_name) %>%
  summarise(
    help_percentage = mean(help) * 100,
    sd = sd(help) * 100,  
    .groups = 'drop'
  ) %>%
  ggplot(aes(y = reorder(domain_name, help_percentage), x = help_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(xmin = help_percentage - sd, xmax = help_percentage + sd),
                width = 0.2, position = position_dodge(0.9)) +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of Help by Domain", y = "Domain", x = "Percentage of Help", fill = "Update on Oct 25th") +
  custom_theme


plot2 <- data %>%
  group_by(new_UI, grade) %>%
  summarise(
    help_percentage = mean(help) * 100,
    sd = sd(help) * 100,
    .groups = 'drop'
  ) %>%
  ggplot(aes(x = factor(grade), y = help_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(ymin = help_percentage - sd, ymax = help_percentage + sd),
                width = 0.2, position = position_dodge(0.9)) +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of Help by Grade", x = "Grade", y = "Percentage of Help", fill = "Update on Oct 25th") +
  custom_theme


plot3 <- data %>%
  group_by(new_UI, modeDifficulty) %>%
  summarise(
    help_percentage = mean(help) * 100,
    sd = sd(help) * 100,
    .groups = 'drop'
  ) %>%
  mutate(
    modeDifficultyLabel = factor(
      case_when(
        modeDifficulty == "0" ~ "Easy",
        modeDifficulty == "1" ~ "Medium",
        modeDifficulty == "2" ~ "Hard"
      ),
      levels = c("Easy", "Medium", "Hard") # Set the desired order
    )
  ) %>%
  ggplot(aes(x = modeDifficultyLabel, y = help_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(ymin = help_percentage - sd, ymax = help_percentage + sd),
                width = 0.2, position = position_dodge(0.9)) +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of Help by Mode Difficulty", x = "Mode Difficulty", y = "Percentage of Help", fill = "Update on Oct 25th") +
  custom_theme


plot4 <- data %>%
  group_by(new_UI, learning_goal) %>%
  summarise(
    help_percentage = mean(help) * 100,
    sd = sd(help) * 100,
    .groups = 'drop'
  ) %>%
  ggplot(aes(x = factor(learning_goal, labels = c("No", "Yes")), y = help_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_errorbar(aes(ymin = help_percentage - sd, ymax = help_percentage + sd),
                width = 0.2, position = position_dodge(0.9)) +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of Help for Learning Goal Sessions", x = "Learning Goal Session", y = "Percentage of Help", fill = "Update on Oct 25th") +
  custom_theme


# Combine all plots into a 2x2 grid
grid.arrange(plot1, plot2, plot3, plot4, ncol = 2)

# ---------------------------------------------------------------------------- Help - without Error Bars
plot1 <- data %>%
  group_by(new_UI, domain_name) %>%
  summarise(
    help_percentage = mean(help) * 100,
    sd = sd(help) * 100,  
    .groups = 'drop'
  ) %>%
  ggplot(aes(y = reorder(domain_name, help_percentage), x = help_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of Help by Domain", y = "Domain", x = "Percentage of Help", fill = "Update on Oct 25th") +
  custom_theme


plot2 <- data %>%
  group_by(new_UI, grade) %>%
  summarise(
    help_percentage = mean(help) * 100,
    sd = sd(help) * 100,
    .groups = 'drop'
  ) %>%
  ggplot(aes(x = factor(grade), y = help_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of Help by Grade", x = "Grade", y = "Percentage of Help", fill = "Update on Oct 25th") +
  custom_theme


plot3 <- data %>%
  group_by(new_UI, modeDifficulty) %>%
  summarise(
    help_percentage = mean(help) * 100,
    sd = sd(help) * 100,
    .groups = 'drop'
  ) %>%
  mutate(
    modeDifficultyLabel = factor(
      case_when(
        modeDifficulty == "0" ~ "Easy",
        modeDifficulty == "1" ~ "Medium",
        modeDifficulty == "2" ~ "Hard"
      ),
      levels = c("Easy", "Medium", "Hard") # Set the desired order
    )
  ) %>%
  ggplot(aes(x = modeDifficultyLabel, y = help_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of Help by Mode Difficulty", x = "Mode Difficulty", y = "Percentage of Help", fill = "Update on Oct 25th") +
  custom_theme


plot4 <- data %>%
  group_by(new_UI, learning_goal) %>%
  summarise(
    help_percentage = mean(help) * 100,
    sd = sd(help) * 100,
    .groups = 'drop'
  ) %>%
  ggplot(aes(x = factor(learning_goal, labels = c("No", "Yes")), y = help_percentage, fill = as.factor(new_UI))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = custom_colors) +  # Apply consistent colors
  labs(title = "Percentage of Help for Learning Goal Sessions", x = "Learning Goal Session", y = "Percentage of Help", fill = "Update on Oct 25th") +
  custom_theme


# Combine all plots into a 2x2 grid
grid.arrange(plot1, plot2, plot3, plot4, ncol = 2)

##------------------------------------------------------------------------------ Statistical analysis

# Summarize the data: Calculate the mean and standard deviation of "help" usage before and after the new UI
help_summary <- data %>%
  group_by(new_UI) %>%
  summarise(
    mean_help = mean(help, na.rm = TRUE),  # Average "help" usage
    sd_help = sd(help, na.rm = TRUE),      # Standard deviation of "help" usage
    n = n()                                # Sample size
  )

# Perform an independent t-test to test for differences in "help" usage
t_test_help <- t.test(
  help ~ new_UI,  # Test if "help" differs between "Before" and "After"
  data = data,
  var.equal = FALSE  # Use Welch's t-test by default
)

# Output results
cat("Summary of Help Usage by New UI:\n")
print(help_summary)
cat("\nT-Test Results:\n")
print(t_test_help)


# Define a function to perform t-tests for subgroups
perform_subgroup_t_test <- function(data, subgroup_var) {
  data %>%
    group_by(!!sym(subgroup_var)) %>%  # Group by the subgroup variable
    summarise(
      t_test_result = list(t.test(help ~ new_UI, data = cur_data(), var.equal = FALSE)),  # Perform t-test
      .groups = "drop"
    ) %>%
    mutate(
      subgroup = !!sym(subgroup_var),
      t_statistic = map_dbl(t_test_result, ~ .x$statistic),
      p_value = map_dbl(t_test_result, ~ .x$p.value),
      mean_diff = map_dbl(t_test_result, ~ diff(.x$estimate)),
      conf_low = map_dbl(t_test_result, ~ .x$conf.int[1]),
      conf_high = map_dbl(t_test_result, ~ .x$conf.int[2])
    ) %>%
    select(subgroup, t_statistic, p_value, mean_diff, conf_low, conf_high)
}

# Apply the function for each subgroup variable
results_by_domain <- perform_subgroup_t_test(data, "domain_id")
results_by_grade <- perform_subgroup_t_test(data, "grade")
results_by_difficulty <- perform_subgroup_t_test(data, "modeDifficulty")
results_by_learning_goal <- perform_subgroup_t_test(data, "learning_goal")

# Display results
results_by_domain
results_by_grade
results_by_difficulty
results_by_learning_goal


# ---------------------------------------------------------------------------- Percentage correct without

correct_answers_domain <- data %>%
  group_by(new_UI, domain_id) %>%
  summarise(
    total_responses = n(),
    correct_responses = sum(correct_answered == "1"),
    correct_percentage = mean(correct_answered == "1") * 100,
    .groups = 'drop'
  ) %>%
  mutate(
    UI_Status = new_UI,  # Consistent with "Before" and "After"
    domain_name = domain_names[as.character(domain_id)]
  )

plot1 <- ggplot(correct_answers_domain, aes(x = correct_percentage, y = domain_name, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Percentage of Correct Answers by Domain", x = "Percentage of Correct Answers", y = "Domain", fill = "Update on Oct 25th") +
  custom_theme

correct_answers_grade <- data %>%
  group_by(new_UI, grade) %>%
  summarise(
    total_responses = n(),
    correct_responses = sum(correct_answered == "1"),
    correct_percentage = mean(correct_answered == "1") * 100,
    .groups = 'drop'
  ) %>%
  mutate(UI_Status = new_UI)

plot2 <- ggplot(correct_answers_grade, aes(x = factor(grade), y = correct_percentage, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Percentage of Correct Answers by Grade", x = "Grade", y = "Percentage of Correct Answers", fill = "Update on Oct 25th") +
  custom_theme


correct_answers_difficulty <- data %>%
  group_by(new_UI, modeDifficulty) %>%
  summarise(
    total_responses = n(),
    correct_responses = sum(correct_answered == "1"),
    correct_percentage = mean(correct_answered == "1") * 100,
    .groups = 'drop'
  ) %>%
  mutate(
    UI_Status = new_UI,
    Difficulty = factor(
      case_when(
        modeDifficulty == "0" ~ "Easy",
        modeDifficulty == "1" ~ "Medium",
        modeDifficulty == "2" ~ "Hard"
      ),
      levels = c("Easy", "Medium", "Hard")  # Set the correct order
    )
  )

plot3 <- ggplot(correct_answers_difficulty, aes(x = Difficulty, y = correct_percentage, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Percentage of Correct Answers by Difficulty", x = "Difficulty", y = "Percentage of Correct Answers", fill = "Update on Oct 25th") +
  custom_theme

correct_answers_learning <- data %>%
  group_by(new_UI, learning_goal) %>%
  summarise(
    total_responses = n(),
    correct_responses = sum(correct_answered == "1"),
    correct_percentage = mean(correct_answered == "1") * 100,
    .groups = 'drop'
  ) %>%
  mutate(
    UI_Status = new_UI,
    LearningGoal = factor(ifelse(learning_goal == 1, "Yes", "No"), levels = c("No", "Yes"))
  )

plot4 <- ggplot(correct_answers_learning, aes(x = LearningGoal, y = correct_percentage, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Percentage of Correct Answers by Learning Goal", x = "Learning Goal", y = "Percentage of Correct Answers", fill = "Update on Oct 25th") +
  custom_theme

grid.arrange(plot1, plot2, plot3, plot4, ncol = 2)


# ---------------------------------------------------------------------------- Percentage correct with

correct_answers_domain <- data %>%
  group_by(new_UI, domain_id) %>%
  summarise(
    total_responses = n(),
    correct_responses = sum(correct_answered == "1"),
    correct_percentage = mean(correct_answered == "1") * 100,
    sd = sd(correct_answered == "1") * 100,  # Calculate SD
    .groups = 'drop'
  ) %>%
  mutate(
    UI_Status = new_UI,  
    domain_name = domain_names[as.character(domain_id)]
  )

plot1 <- ggplot(correct_answers_domain, aes(x = correct_percentage, y = domain_name, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  geom_errorbar(aes(xmin = correct_percentage - sd, xmax = correct_percentage + sd), 
                width = 0.2, position = position_dodge(0.8)) +
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Percentage of Correct Answers by Domain", x = "Percentage of Correct Answers", y = "Domain", fill = "Update on Oct 25th") +
  custom_theme


correct_answers_grade <- data %>%
  group_by(new_UI, grade) %>%
  summarise(
    total_responses = n(),
    correct_responses = sum(correct_answered == "1"),
    correct_percentage = mean(correct_answered == "1") * 100,
    sd = sd(correct_answered == "1") * 100,
    .groups = 'drop'
  ) %>%
  mutate(UI_Status = new_UI)

plot2 <- ggplot(correct_answers_grade, aes(x = factor(grade), y = correct_percentage, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  geom_errorbar(aes(ymin = correct_percentage - sd, ymax = correct_percentage + sd), 
                width = 0.2, position = position_dodge(0.8)) +
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Percentage of Correct Answers by Grade", x = "Grade", y = "Percentage of Correct Answers", fill = "Update on Oct 25th") +
  custom_theme


correct_answers_difficulty <- data %>%
  group_by(new_UI, modeDifficulty) %>%
  summarise(
    total_responses = n(),
    correct_responses = sum(correct_answered == "1"),
    correct_percentage = mean(correct_answered == "1") * 100,
    sd = sd(correct_answered == "1") * 100,
    .groups = 'drop'
  ) %>%
  mutate(
    UI_Status = new_UI,
    Difficulty = factor(
      case_when(
        modeDifficulty == "0" ~ "Easy",
        modeDifficulty == "1" ~ "Medium",
        modeDifficulty == "2" ~ "Hard"
      ),
      levels = c("Easy", "Medium", "Hard")
    )
  )

plot3 <- ggplot(correct_answers_difficulty, aes(x = Difficulty, y = correct_percentage, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  geom_errorbar(aes(ymin = correct_percentage - sd, ymax = correct_percentage + sd), 
                width = 0.2, position = position_dodge(0.8)) +
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Percentage of Correct Answers by Difficulty", x = "Difficulty", y = "Percentage of Correct Answers", fill = "Update on Oct 25th") +
  custom_theme


correct_answers_learning <- data %>%
  group_by(new_UI, learning_goal) %>%
  summarise(
    total_responses = n(),
    correct_responses = sum(correct_answered == "1"),
    correct_percentage = mean(correct_answered == "1") * 100,
    sd = sd(correct_answered == "1") * 100,
    .groups = 'drop'
  ) %>%
  mutate(
    UI_Status = new_UI,
    LearningGoal = factor(ifelse(learning_goal == 1, "Yes", "No"), levels = c("No", "Yes"))
  )

plot4 <- ggplot(correct_answers_learning, aes(x = LearningGoal, y = correct_percentage, fill = UI_Status)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  geom_errorbar(aes(ymin = correct_percentage - sd, ymax = correct_percentage + sd), 
                width = 0.2, position = position_dodge(0.8)) +
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Percentage of Correct Answers by Learning Goal", x = "Learning Goal", y = "Percentage of Correct Answers", fill = "Update on Oct 25th") +
  custom_theme

grid.arrange(plot1, plot2, plot3, plot4, ncol = 2)
# ---------------------------------------------------------------------------- Testing significance 

# Convert `correct_answered` to numeric
data$correct_answered <- as.numeric(as.character(data$correct_answered))

# Overall t-test for correct answers (Before vs After)
overall_t_test <- t.test(correct_answered ~ new_UI, data = data, var.equal = FALSE)

# Summarize overall mean and SD by new_UI
overall_summary <- data %>%
  group_by(new_UI) %>%
  summarise(
    mean_correct = mean(correct_answered, na.rm = TRUE) * 100,  # Mean in percentage
    sd_correct = sd(correct_answered, na.rm = TRUE) * 100,      # Standard deviation in percentage
    n = n()                                                    # Sample size
  )

# Print overall results
cat("Overall Summary:\n")
print(overall_summary)
cat("\nOverall T-Test Results:\n")
print(overall_t_test)

# Define a function to test for significance by subgroup
perform_significance_test <- function(data, group_var) {
  data %>%
    group_by(!!sym(group_var)) %>%  # Group by the specified variable
    summarise(
      t_test_result = list(t.test(correct_answered ~ new_UI, data = cur_data(), var.equal = FALSE)),
      .groups = "drop"
    ) %>%
    mutate(
      subgroup = !!sym(group_var),
      t_statistic = map_dbl(t_test_result, ~ .x$statistic),
      p_value = map_dbl(t_test_result, ~ .x$p.value),
      mean_diff = map_dbl(t_test_result, ~ diff(.x$estimate) * 100),  # Mean difference in percentage
      conf_low = map_dbl(t_test_result, ~ .x$conf.int[1] * 100),
      conf_high = map_dbl(t_test_result, ~ .x$conf.int[2] * 100)
    ) %>%
    select(subgroup, t_statistic, p_value, mean_diff, conf_low, conf_high)
}

# Test significance for each subgroup
results_by_domain <- perform_significance_test(data, "domain_id")
results_by_grade <- perform_significance_test(data, "grade")
results_by_difficulty <- perform_significance_test(data, "modeDifficulty")
results_by_learning_goal <- perform_significance_test(data, "learning_goal")

# Print subgroup results
cat("\nSignificance by Domain:\n")
print(results_by_domain)
cat("\nSignificance by Grade:\n")
print(results_by_grade)
cat("\nSignificance by Difficulty:\n")
print(results_by_difficulty)
cat("\nSignificance by Learning Goal:\n")
print(results_by_learning_goal)

## ----------------------------------------------------------------------------- basic overview :

# Total items answered
items_answered <- data %>%
  group_by(new_UI) %>%
  summarise(
    total_items = n(),
    .groups = "drop"
  )
t_test_items <- t.test(item_id ~ new_UI, data = data)

# Average response time and significance test
response_time <- data %>%
  group_by(new_UI) %>%
  summarise(
    avg_response_time = mean(response_in_seconds, na.rm = TRUE),
    sd_response_time = sd(response_in_seconds, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  )
t_test_response_time <- t.test(response_in_seconds ~ new_UI, data = data)

# Average daily unique users and significance test
t_test_daily_users <- t.test(
  daily_users ~ new_UI,
  data = data %>%
    group_by(new_UI, date) %>%
    summarise(daily_users = n_distinct(user_id), .groups = "drop")
)

# Average daily sessions per user and significance test
daily_sessions_per_user <- data %>%
  group_by(new_UI, date) %>%
  summarise(
    total_sessions = n(),
    unique_users = n_distinct(user_id),
    avg_sessions_per_user = total_sessions / unique_users,
    .groups = "drop"
  ) %>%
  group_by(new_UI) %>%
  summarise(
    avg_sessions_per_user = mean(avg_sessions_per_user, na.rm = TRUE),
    sd_sessions_per_user = sd(avg_sessions_per_user, na.rm = TRUE),
    n_days = n(),  # Number of days
    .groups = "drop"
  )
t_test_sessions_per_user <- t.test(
  avg_sessions_per_user ~ new_UI,
  data = data %>%
    group_by(new_UI, date) %>%
    summarise(
      total_sessions = n(),
      unique_users = n_distinct(user_id),
      avg_sessions_per_user = total_sessions / unique_users,
      .groups = "drop"
    )
)

# Combine results
descriptives <- items_answered %>%
  left_join(response_time, by = "new_UI") %>%
  left_join(daily_unique_users, by = "new_UI") %>%
  left_join(daily_sessions_per_user, by = "new_UI")

# Print the final descriptive statistics
print(descriptives)

# Print t-test results
cat("\nT-Test Results:\n")
cat("\nResponse Time:\n")
print(t_test_response_time)
cat("\nDaily Unique Users:\n")
print(t_test_daily_users)
cat("\nDaily Sessions Per User:\n")
print(t_test_sessions_per_user)

##------------------------------------------------------------------------------ Temporal pattern


# Ensure `date` is in POSIXct format
data$date <- as.POSIXct(data$date)

# Add `hour` column to the data
data <- data %>%
  mutate(hour = hour(date))  # Extract hour from the date column

# Filter data for "After" the new UI and exclude rows where no_answer = 1 and late_response = 1
filtered_data <- data %>%
  filter(new_UI == "After" & !(late_response == 1 & no_answer == 1))

# Late Responses by Hour of the Day
late_response_by_hour <- filtered_data %>%
  group_by(hour) %>%
  summarize(
    total_responses = n(),
    late_responses = sum(late_response),
    late_response_rate = round(mean(late_response) * 100, 2),
    .groups = "drop"
  )

# Plot Late Response Rate by Hour
plot_hour <- late_response_by_hour %>%
  ggplot(aes(x = hour, y = late_response_rate)) +
  geom_line(color = "#57b0b5", size = 1.2) +
  geom_point(color = "#57b0b5", size = 3) +
  labs(
    title = "Late Response Rate by Hour of Day",
    x = "Hour of Day",
    y = "Late Response Rate (%)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# Late Responses by Weekday
plot_weekday <- ggplot(late_response_by_weekday, aes(x = weekday, y = late_response_rate)) +
  geom_bar(stat = "identity", fill = "#fe6c66") +
  labs(
    title = "Late Responses by Weekday",
    x = "Weekday",
    y = "Late Response Rate (%)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# Late Responses by Week Since New UI
plot_week <- ggplot(late_response_by_week, aes(x = week_since_ui, y = late_response_rate)) +
  geom_line(color = "#57b0b5", size = 1) +
  geom_point(color = "#57b0b5", size = 2) +
  labs(
    title = "Late Responses by Week",
    x = "Week Since New UI",
    y = "Late Response Rate (%)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# Combine all plots into a grid
grid.arrange(plot_hour, plot_weekday, plot_week, ncol = 3)


##------------------------------------------------------------------------------ 
# ANOVA for Late Response Rate by Hour
anova_hour <- aov(late_response ~ as.factor(hour), data = filtered_data)
cat("ANOVA for Late Response Rate by Hour:\n")
summary(anova_hour)

# ANOVA for Late Response Rate by Weekday
anova_weekday <- aov(late_response ~ as.factor(wday(date)), data = filtered_data)
cat("\nANOVA for Late Response Rate by Weekday:\n")
summary(anova_weekday)

# Create the week_since_ui variable
filtered_data <- filtered_data %>%
  mutate(week_since_ui = floor(as.numeric(difftime(date, min(date), units = "weeks"))))


# ANOVA for Late Response Rate by Week Since New UI
anova_week <- aov(late_response ~ as.factor(week_since_ui), data = filtered_data)
cat("\nANOVA for Late Response Rate by Week Since New UI:\n")
summary(anova_week)

# Post-hoc Analysis for Late Response Rate by Hour
tukey_hour <- TukeyHSD(anova_hour)
cat("Post-hoc Analysis for Late Response Rate by Hour:\n")
print(tukey_hour)

# Post-hoc Analysis for Late Response Rate by Weekday
tukey_weekday <- TukeyHSD(anova_weekday)
cat("\nPost-hoc Analysis for Late Response Rate by Weekday:\n")
print(tukey_weekday)

# Post-hoc Analysis for Late Response Rate by Week Since New UI
tukey_week <- TukeyHSD(anova_week)
cat("\nPost-hoc Analysis for Late Response Rate by Week Since New UI:\n")
print(tukey_week)

# Calculate total responses and late responses by hour
responses_by_hour <- filtered_data %>%
  group_by(hour) %>%
  summarize(
    total_responses = n(),
    late_responses = sum(late_response),
    late_response_rate = round(mean(late_response) * 100, 2),
    .groups = "drop"
  )

# Calculate total responses and late responses by weekday
responses_by_weekday <- filtered_data %>%
  mutate(weekday = wday(date, label = TRUE)) %>%
  group_by(weekday) %>%
  summarize(
    total_responses = n(),
    late_responses = sum(late_response),
    late_response_rate = round(mean(late_response) * 100, 2),
    .groups = "drop"
  )

oefenwebDatabase::close_connection(con)
